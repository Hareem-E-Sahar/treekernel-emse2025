package com.koutra.dist.proc.sink;

import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.sax.SAXSource;
import org.apache.fop.apps.FOUserAgent;
import org.apache.fop.apps.Fop;
import org.apache.fop.apps.FopFactory;
import org.apache.log4j.Logger;
import org.apache.xalan.transformer.TrAXFilter;
import org.xml.sax.InputSource;
import org.xml.sax.XMLFilter;
import org.xml.sax.XMLReader;
import com.koutra.dist.proc.model.ContentType;
import com.koutra.dist.proc.model.IFaucet;
import com.koutra.dist.proc.model.IPipelineItem;
import com.koutra.dist.proc.model.XformationException;

/**
 * A FOP zip mux sink consumes a sequence of streams of SAX events generated by a
 * template item and stores them into a zip file, passing it through the FOP
 * processor. This can generate any of the outputs that the FOP processor
 * supports. In order for the FOP processor to work properly, the last
 * transformation step before the FOP processor must be converting the SAX stream
 * into a XSL-FO compliant stream of SAX events. Each FOP processor output will be a
 * separate zip entry in the generated zip file.
 * 
 * @author Pafsanias Ftakas
 */
public class FOPZipMuxSink extends AbstractFileOrStreamMuxSink {

    private static final Logger logger = Logger.getLogger(FOPZipMuxSink.class);

    protected static class DequePayload {

        public IFaucet faucet;

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof DequePayload)) return false;
            DequePayload other = (DequePayload) obj;
            if (faucet == null) return false;
            return faucet.equals(other.faucet);
        }
    }

    protected FopFactory fopFactory;

    protected BlockingDeque<DequePayload> deque;

    protected String fopTargetMimeType;

    protected ZipOutputStream outputStream;

    /**
	 * @deprecated Use any of the initializing constructors instead.
	 */
    public FOPZipMuxSink() {
    }

    /**
	 * Initializing constructor for the Stream type.
	 * @param id the ID of the sink.
	 * @param fopFactory the FOP factory to use.
	 * @param fopTargetMimeType the FOP MIME target type.
	 * @param os the output stream to write to.
	 */
    public FOPZipMuxSink(String id, FopFactory fopFactory, String fopTargetMimeType, ZipOutputStream os) {
        super(id);
        this.fopFactory = fopFactory;
        this.deque = new LinkedBlockingDeque<DequePayload>();
        this.fopTargetMimeType = fopTargetMimeType;
        this.outputStream = os;
    }

    /**
	 * Initializing constructor for the File type.
	 * @param id the ID of the sink.
	 * @param fopFactory the FOP factory to use.
	 * @param fopTargetMimeType the FOP MIME target type.
	 * @param path the file path to write to.
	 */
    public FOPZipMuxSink(String id, FopFactory fopFactory, String fopTargetMimeType, String path) {
        super(id, path);
        this.fopFactory = fopFactory;
        this.deque = new LinkedBlockingDeque<DequePayload>();
        this.fopTargetMimeType = fopTargetMimeType;
        this.outputStream = null;
    }

    /**
	 * Initializing constructor for the Stream type.
	 * @param id the ID of the sink.
	 * @param fopTargetMimeType the FOP MIME target type.
	 * @param os the output stream to write to.
	 */
    public FOPZipMuxSink(String id, String fopTargetMimeType, ZipOutputStream os) {
        this(id, FopFactory.newInstance(), fopTargetMimeType, os);
    }

    /**
	 * Initializing constructor for the File type.
	 * @param id the ID of the sink.
	 * @param fopTargetMimeType the FOP MIME target type.
	 * @param path the file path to write to.
	 */
    public FOPZipMuxSink(String id, String fopTargetMimeType, String path) {
        this(id, FopFactory.newInstance(), fopTargetMimeType, path);
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 * 
	 * @param contentType the type that we want this sink to support.
	 * @return true iff this sink supports the content type argument.
	 */
    @Override
    public boolean supportsInput(ContentType contentType) {
        switch(contentType) {
            case XML:
                return true;
            case ByteStream:
            case CharStream:
            case ResultSet:
            default:
                return false;
        }
    }

    /**
	 * Override the implementation in the abstract sink to add a check that the faucet
	 * supports the proper content type.
	 */
    @Override
    protected void checkFaucetValidity(IFaucet faucet) {
        super.checkFaucetValidity(faucet);
        if (!faucet.supportsOutput(ContentType.XML)) throw new IllegalArgumentException("Faucet '" + faucet.getId() + "' must support the XML content type.");
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 */
    @Override
    public void registerSource(Object source) {
        IFaucet faucet = (IFaucet) source;
        DequePayload payload = new DequePayload();
        payload.faucet = faucet;
        if (deque.contains(payload)) return;
        if (logger.isTraceEnabled()) logger.trace("Registering faucet: " + faucet + " with the mux deque");
        while (true) {
            try {
                deque.putLast(payload);
                break;
            } catch (InterruptedException e) {
            }
        }
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 */
    @Override
    public String dumpPipeline() {
        DequePayload payload = deque.peekFirst();
        return getClass().getName() + ": " + (payload == null ? "null" : payload.faucet);
    }

    @Override
    public void dispose() {
        switch(type) {
            case File:
                try {
                    outputStream.close();
                } catch (IOException e) {
                    throw new XformationException("Unable to close output stream", e);
                }
                break;
            case Stream:
                break;
        }
    }

    /**
	 * Helper to get the first reader in the reader chain.
	 * @param previousFilter the recursive parameter.
	 * @return the first reader in the reader chain.
	 */
    private XMLReader getRealReader(Object previousFilter) {
        if (previousFilter instanceof XMLFilter) {
            XMLFilter filter = (XMLFilter) previousFilter;
            return getRealReader(filter.getParent());
        } else {
            return (XMLReader) previousFilter;
        }
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 */
    @Override
    public void consume() {
        if (!hookedUp && faucetTemplate == null) throw new XformationException("Sink has not been set up correctly: " + "faucet has not been set");
        switch(type) {
            case File:
                try {
                    outputStream = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(path)));
                } catch (FileNotFoundException e) {
                    throw new XformationException("Unable to create output stream", e);
                }
                break;
            case Stream:
                break;
        }
        if (!hookedUp) {
            if (faucetTemplate instanceof IPipelineItem) {
                ((IPipelineItem) faucetTemplate).consume(this);
            }
        }
        try {
            int counter = 0;
            while (true) {
                DequePayload payload = null;
                try {
                    payload = deque.takeFirst();
                } catch (InterruptedException ie) {
                }
                if (payload == null) break;
                IFaucet faucet = payload.faucet;
                if (logger.isTraceEnabled()) logger.trace("Retrieved faucet: " + faucet + " from the mux deque");
                if (faucet == null) break;
                ZipEntry entry = new ZipEntry("entry" + counter++);
                outputStream.putNextEntry(entry);
                InputSource inputSource = null;
                if (faucet instanceof IPipelineItem) {
                    inputSource = (InputSource) ((IPipelineItem) faucet).consume(this);
                }
                FOUserAgent foUserAgent = fopFactory.newFOUserAgent();
                try {
                    Object faucetObject = faucet.getSource(ContentType.XML);
                    if (logger.isTraceEnabled()) logger.trace("Sink is using reader: " + faucetObject);
                    XMLFilter filter = (XMLFilter) faucetObject;
                    if (!(filter instanceof TrAXFilter)) throw new XformationException("Unsupported transformation class " + filter.getClass().getName());
                    Transformer transformer = ((TrAXFilter) filter).getTransformer();
                    Fop fop = fopFactory.newFop(fopTargetMimeType, foUserAgent, outputStream);
                    Result result = new SAXResult(fop.getDefaultHandler());
                    SAXSource transformSource = new SAXSource(getRealReader(filter), inputSource);
                    transformer.transform(transformSource, result);
                } catch (Exception e) {
                    throw new XformationException("Unable to set up transform", e);
                }
                outputStream.closeEntry();
                faucet.dispose();
            }
            outputStream.close();
            faucetTemplate.dispose();
        } catch (IOException ioe) {
            logger.error("Error while consuming input", ioe);
            throw new XformationException("Unable to transform stream", ioe);
        }
    }

    /**
	 * Override the <code>Streamable</code> implementation in order to deserialize
	 * local members.
	 */
    @Override
    public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {
        super.readFrom(in);
        this.fopFactory = FopFactory.newInstance();
        this.deque = new LinkedBlockingDeque<DequePayload>();
        this.fopTargetMimeType = in.readUTF();
        this.outputStream = null;
    }

    /**
	 * Override the <code>Streamable</code> implementation in order to serialize local
	 * members.
	 */
    @Override
    public void writeTo(DataOutputStream out) throws IOException {
        super.writeTo(out);
        out.writeUTF(fopTargetMimeType);
    }
}
