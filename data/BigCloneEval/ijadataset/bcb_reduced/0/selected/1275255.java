package org.echarts.edt.core;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.echarts.edt.internal.core.EChartsDKProject;
import org.echarts.edt.internal.core.EChartsModelManager;
import org.echarts.edt.internal.core.EChartsModelStatus;
import org.echarts.edt.internal.core.EChartsPathEntry;
import org.echarts.edt.internal.core.builder.BaseDevelopmentKit;
import org.echarts.edt.internal.core.builder.EChartsDevelopmentKitFactory;
import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IProjectDescription;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.IWorkspaceDescription;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.FileLocator;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Plugin;
import org.eclipse.core.runtime.QualifiedName;
import org.eclipse.jdt.core.IClasspathEntry;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.launching.JavaRuntime;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.osgi.service.prefs.BackingStoreException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * The plug-in runtime class for the ECharts model plug-in containing the core
 * (UI-free) support for ECharts Projects.
 * 
 * Like all plug-in runtime classes (subclasses of <code>Plugin</code>), this
 * class is automatically instantiated by the platform when the plug-in gets
 * activated. Clients must not attempt to instantiate the plug-in runtime
 * classes directly.
 * 
 * The single instance of this class can be accessed from any plug-in declaring
 * the ECharts model plug-in as a prerequeisite via
 * EChartsCore.getEChartsCore(). The ECharts model plug-in will be activated
 * automatically if not already active.
 * 
 * @author Stephen Gevers, Chris Strieter
 * @version $Revision: 1.54 $
 */
public class EChartsCore extends Plugin {

    /**
	 * The plug-in identifier of the ECharts core support (value
	 * "org.echarts.edt.core")
	 */
    public static final String PLUGIN_ID = "org.echarts.edt.core";

    /**
	 * The singleton instance of the EChartsCore plugin.
	 */
    private static EChartsCore plugin = null;

    /**
	 * Option key for the default DK
	 */
    public static final String ECHARTS_DEFAULT_DK = PLUGIN_ID + ".DefaultDK";

    /**
	 * Option key for the location of the Python executable.
	 */
    public static final String ECHARTS_PYTHON_EXE = PLUGIN_ID + ".PythonLocation";

    /**
	 * Option key for the default folder for the .java files generated by the
	 * translator.
	 */
    public static final String ECHARTS_DEFAULT_OUT = PLUGIN_ID + ".DefaultOut";

    /**
	 * Option key for the default folder where .ech packages and files are
	 * found.
	 */
    public static final String ECHARTS_DEFAULT_SRC = PLUGIN_ID + ".DefaultSrc";

    /**
	 * The identifier for the ECharts builder (value
	 * "org.echarts.edt.core.echartsbuilder")
	 */
    public static final String BUILDER_ID = PLUGIN_ID + ".echartsbuilder";

    /**
	 * The identifier for the ECharts nature (value
	 * "org.echarts.edt.core.echartsnature")
	 */
    public static final String NATURE_ID = PLUGIN_ID + ".echartsnature";

    /**
	 * The identifier for the ECharts nature (value
	 * "org.echarts.edt.core.echartsnature")
	 */
    public static final String DK_NATURE = PLUGIN_ID + ".echartsdknature";

    /**
	 * The path for the DK Container
	 * (value org.echarts.edt.core.dkContainer)
	 */
    public static final String DK_CONTAINER_PATH = PLUGIN_ID + ".dkContainer";

    /**
	 * The value for of the ECharts classpath variable used to add the
	 * echarts.jar file to the Java Classpath.
	 */
    public static final String ECHARTS_CLASSPATHVAR = "ECHARTS_DIR";

    /**
	 * The identifier for the Configuration Error markers
	 */
    public static final String CONFIGURATION_MARKER = PLUGIN_ID + ".configurationProblem";

    /**
	 * The identifier for .ech syntax and semantic error markers.
	 */
    public static final String MACHINE_PROBLEM_MARKER = PLUGIN_ID + ".echProblem";

    /**
	 * The identifier for .java syntax and semantic error markers.
	 */
    public static final String JAVA_PROBLEM_MARKER = PLUGIN_ID + ".ech2JavaProblem";

    /**
	 * Persistent property key associated with a <code>.java</code> file
	 * for retrieving the path of the {@link IMachine} that is responsible for
	 * its generation.
	 */
    public static final QualifiedName MACHINESOURCE = new QualifiedName(EChartsCore.PLUGIN_ID + ".machine", "source");

    /**
	 * Local variable that holds the {@link EChartsModelManager} singleton.  This
	 * code is also responsible for creating the initial instance of the singleton
	 * through the call to getEChartsModelManager.
	 */
    private static EChartsModelManager modelManager = EChartsModelManager.getEChartsModelManager();

    /**
	 * Represents an empty Java classpath.
	 */
    private static final IClasspathEntry[] EMPTY_CLASSPATH = new IClasspathEntry[0];

    /**
	 * The Hashmap of installed development kits
	 */
    private HashMap dkMap = null;

    /**
	 * Constructor for the plugin, not to be called by client code.
	 */
    public EChartsCore() {
        plugin = this;
    }

    /**
	 * Called when the bundle associated with this plugin is first loaded.
	 * 
	 * @param context BundleContext
	 * @throws Exception
	 * @see org.eclipse.core.runtime.Plugins#start(org.osgi.framework.BundleContext)
	 * 
	 */
    public void start(BundleContext context) throws Exception {
        super.start(context);
    }

    /**
	 * Called when the bundle associated with this plugin is stopped. Sets the
	 * {@link #plugin} field used by {@link #getDefault()} to <code>null</code>
	 * because because the plugin cannot be used after it is stopped.
	 * @param context BundleContext
	 * 
	 * @throws Exception
	 * @see org.eclipse.core.runtime.Plugin#stop(org.osgi.framework.BundleContext)
	 * 
	 */
    public void stop(BundleContext context) throws Exception {
        plugin = null;
        super.stop(context);
    }

    /**
	 * Returns the shared instance
	 * 
	 * @return the shared instance
	 */
    public static EChartsCore getDefault() {
        return plugin;
    }

    /**
	 * Get the singleton EChartsCore
	 * 
	 * @return the singleton EChartsCore
	 */
    public static EChartsCore getEChartsCore() {
        return plugin;
    }

    /**
	 * Get the EChartsModel representing the root of the model tree.
	 * 
	 * @param root
	 *            The EChartsModel's resource is the workspace root.
	 * @return the model
	 */
    public static IEChartsModel create(IWorkspaceRoot root) {
        if (root == null) {
            return null;
        }
        return modelManager.getEChartsModel();
    }

    /**
	 * Get the complete set of ECharts options
	 * 
	 * @return the map of ECharts Options
	 * @throws CoreException When the retrieval of options fails.
	 */
    public static HashMap getOptions() throws CoreException {
        try {
            return modelManager.getOptions();
        } catch (BackingStoreException e) {
            throw new CoreException(getExceptionStatus("Error processing preferences", e));
        }
    }

    /**
	 * Get a map of the default values for the ECharts Options
	 * 
	 * @return the map of default values
	 */
    public static HashMap getOptionsDefault() {
        return modelManager.getOptionsDefaults();
    }

    /**
	 * Get the value of the ECharts Core option.
	 * 
	 * @param name
	 *            The name of the option desired.
	 * @return The value of the ECharts Core option specified by name or
	 *         <code>null</code> if the option doesn't exist.
	 */
    public static String getOption(String name) {
        return modelManager.getOption(name);
    }

    /**
	 * Creates and returns a new echarts path entry of kind
	 * {@link IEChartsPathEntry#CPE_SOURCE CPE_SOURCE} for the project's source
	 * folder identified by the given absolute workspace-relative path. This
	 * echarts path entry defines a root source folder on the path where ECharts
	 * source files can be found. Translated Java files will be placed in the
	 * location specified by the {@link IEChartsProject#getOutputLocation()}
	 * method on the target project. This method is a convenience method for
	 * {@link #newSourceEntry(IPath, IPath) EChartsCore.newSourceEntry(name, null)}
	 * 
	 * @param path
	 *            Workspace relative path for the source entry.
	 * @return a new IEChartsPathEntry
	 */
    public static IEChartsPathEntry newSourceEntry(IPath path) {
        return newSourceEntry(path, null);
    }

    /**
	 * Creates and returns a new echarts path entry of kind
	 * {@link IEChartsPathEntry#CPE_SOURCE CPE_SOURCE} for the project's source
	 * folder identified by the given absolute workspace-relative path. This
	 * echarts path entry defines a root source folder on the path where ECharts
	 * source files can be found. Translated Java files will be placed in the
	 * location specified by the <code>out</code> path or the location
	 * specified by the {@link IEChartsProject#getOutputLocation()} method on
	 * the target project if the <code>out</code> parameter is
	 * <code>null</code>
	 * 
	 * @param path
	 *            Workspace relative path for the source entry
	 * @param out
	 *            Workspace relative path for the location where generated .java
	 *            files are to be placed when translating ECharts source files
	 *            found in locations relative to the <code>path</code>
	 *            parameter.
	 * @return a new IEChartsPathEntry
	 */
    public static IEChartsPathEntry newSourceEntry(IPath path, IPath out) {
        Assert.isNotNull(path, "ECharts path entry must not be null");
        return new EChartsPathEntry(IEChartsPathEntry.CPE_SOURCE, path, out);
    }

    /**
	 * Create an IEChartsProject for the given project. The project must exist
	 * and must have an {@link #NATURE_ID ECharts project nature}. Note that
	 * this method will return the same object instance for every call that is
	 * passed the same project.
	 * 
	 * @param project
	 *            The project for which the IEChartsProject corresponds.
	 * @return The IEChartsProject for the specified project or
	 *         <code>null</code> if the project is not an ECharts project.
	 * @throws EChartsModelException 
	 */
    public static IEChartsProject create(IProject project) throws EChartsModelException {
        if (project == null) {
            return null;
        }
        IEChartsModel echartsModel = modelManager.getEChartsModel();
        return echartsModel.getEChartsProject(project);
    }

    /**
	 * Create and return the IMachine found at the specified path. Note that
	 * this method will return the same object instance every time the same path
	 * is specified.
	 * 
	 * @param path
	 *            The Workspace relative path of an ECharts Source File.
	 * @return The IMachine specified in the Source File.
	 * @throws EChartsModelException 
	 */
    public static IMachine createMachine(IPath path) throws EChartsModelException {
        return modelManager.getMachine(path);
    }

    /**
	 * Create and return the IMachine represented by the specified file. Note
	 * that this method will return the same object instance every time the same
	 * file is specified.
	 * 
	 * @param file
	 *            The Source File containing the machine definition.
	 * @return The IMachine specified in the Source File.
	 * @throws EChartsModelException 
	 */
    public static IMachine create(IFile file) throws EChartsModelException {
        return modelManager.getMachine(file);
    }

    /**
	 * Create and return the IEChartsPackageFragment or IEChartsPackageFragmentRoot
	 * associated with the specified folder or <code>null</code> if none is
	 * associated.
	 * @param folder The folder corresponding to the fragment or fragment root.
	 * @return the fragment or root associated with the folder.
	 * @throws EChartsModelException 
	 */
    public static IEChartsElement create(IFolder folder) throws EChartsModelException {
        return modelManager.getElement(folder);
    }

    /**
	 * Creates and returns a new echarts path entry of kind
	 * {@link IEChartsPathEntry#CPE_PROJECT CPE_PROJECT} for the
	 * workspace-relative path that corresponds to an ECharts Project. When a
	 * project contains an entry of this type, the Source Files on the specified
	 * project will be used to resolve dependencies on files in this project.
	 * 
	 * @param path
	 *            The workspace relative path of the dependent project.
	 * @return A new IEChartsPathEntry corresponding to the dependent project.
	 * @throws EChartsModelException 
	 */
    public static IEChartsPathEntry newProjectEntry(IPath path) throws EChartsModelException {
        Assert.isNotNull(path, "Project Entry must not be null");
        IProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(path.toString());
        Assert.isNotNull(project, "Not a project");
        return newProjectEntry(project);
    }

    /**
	 * Creates and returns a new echarts path entry of kind
	 * {@link IEChartsPathEntry#CPE_PROJECT CPE_PROJECT} for the
	 * workspace-relative path that corresponds to an ECharts Project. When a
	 * project contains an entry of this type, the Source Files on the specified
	 * project will be used to resolve dependencies on files in this project.
	 * 
	 * @param project
	 *            The dependent ECharts Project
	 * @return A new IEChartsPathEntry corresponding to the dependent project.
	 * @throws EChartsModelException 
	 */
    public static IEChartsPathEntry newProjectEntry(IProject project) throws EChartsModelException {
        Assert.isNotNull(project, "Null Project");
        boolean echartsProject = false;
        try {
            echartsProject = project.hasNature(NATURE_ID);
        } catch (CoreException e) {
            throw coreException("Checking nature for " + project.getName(), e);
        }
        Assert.isTrue(echartsProject, "Not an ECharts Project");
        return new EChartsPathEntry(IEChartsPathEntry.CPE_PROJECT, project.getFullPath(), null);
    }

    /**
	 * Create a new path entry that points to a directory outside the workspace.
	 * 
	 * @param path
	 *            The path to the directory containing eCharts source files.
	 * @return The new IEChartsPathEntry
	 */
    public static IEChartsPathEntry newLibraryEntry(IPath path) {
        Assert.isNotNull(path);
        return new EChartsPathEntry(IEChartsPathEntry.CPE_LIBRARY, path, null);
    }

    /**
	 * Create a new path entry for a classpath container.
	 * 
	 * @param path
	 *            The path key of the container.
	 * @return The new IEChartsPathEntry
	 */
    public static IEChartsPathEntry newContainerEntry(IPath path) {
        Assert.isNotNull(path);
        return new EChartsPathEntry(IEChartsPathEntry.CPE_CONTAINER, path, null);
    }

    /**
	 * Create a new variable based path entry that points to a directory outside
	 * the workspace.
	 * 
	 * @param path
	 *            The path to the directory containing eCharts source files. The
	 *            first segment of the path contains a JavaCore variable name.
	 * @return The new IEChartsPathEntry
	 */
    public static IEChartsPathEntry newVariableEntry(IPath path) {
        Assert.isNotNull(path);
        return new EChartsPathEntry(IEChartsPathEntry.CPE_VARIABLE, path, null);
    }

    /**
	 * Utility method for creating a folder in the workspace.
	 * 
	 * @param folder
	 *            the folder to be created.
	 * @param force
	 *            a flag controlling how to deal with resources that are not in
	 *            sync with the local file system
	 * @param local
	 *            a flag controlling whether onr not the folder will be local
	 *            after its creation.
	 * @param monitor
	 *            a progress monitor, or <code>null</code> if progress
	 *            reporting is not desired.
	 * @throws EChartsModelException
	 *             if this method fails. Reasons include: <bl>
	 *             <li>The resource contains a resource of a different type at
	 *             the same path as this resource</li>
	 *             <li>The parent of this resource is a project that is not
	 *             open</li>
	 *             <li>The parent contains a resource of a different type at
	 *             the same path as this resource</li>
	 *             <li>The name of this resource is not valid (according to
	 *             IWorkspace.validateName).</li>
	 *             <li>The corresponding location in the file system is
	 *             occupied by a file (as opposed to a directory)</li>
	 *             <li>The corresponding location in the local file system is
	 *             occupied by a folder and <code>force</code> is
	 *             <code>false</code>.</li>
	 *             <li>Resource changes are disallowed during certain types of
	 *             resource change event notification</li>
	 *             </bl>
	 */
    public static void createFolder(IFolder folder, boolean force, boolean local, IProgressMonitor monitor) throws EChartsModelException {
        if (!folder.exists()) {
            IContainer parent = folder.getParent();
            if (parent instanceof IFolder) {
                createFolder((IFolder) parent, force, local, null);
            }
            try {
                folder.create(force, local, monitor);
            } catch (CoreException e) {
                throw coreException("cannot create " + folder.getName(), e);
            }
        }
    }

    /**
	 * Get the singleton instance of the model.
	 * 
	 * @return the model.
	 */
    public static IEChartsModel getEChartsModel() {
        return modelManager.getEChartsModel();
    }

    /**
	 * Convenience method to create the default ECharts path. This method
	 * returns an array of entries containing the default source location of eCharts
	 * source files, and the Container entry for the DK.
	 * @param project IProject the project for which the default path is to be generated.
	 * @param useJavaSrcDir The default Java source entry if <code>true</code> and the default ECharts source entry if <code>false</code>
	 * 
	 * @return an array of IEChartspathEntry correpsonding the the eCharts path.
	 */
    public static IEChartsPathEntry[] generateDefaultPath(IProject project, boolean useJavaSrcDir) {
        IEChartsPathEntry ret[] = new IEChartsPathEntry[2];
        ret[0] = newContainerEntry(new Path(DK_CONTAINER_PATH));
        if (useJavaSrcDir) ret[1] = newSourceEntry(project.getFullPath().addTrailingSeparator().append("src")); else ret[1] = newSourceEntry(project.getFullPath().addTrailingSeparator().append(getOption(ECHARTS_DEFAULT_SRC)));
        return ret;
    }

    /**
	 * Create a new EChartsProject and JavaProject for the specified IProject.
	 * This is a convenience method to create a new project using defaults. This
	 * method invokes
	 * {@link #newProject(IProject, boolean, boolean) newProject(project, null, null)}
	 *  
	 * @param project The eclipse project which shall have the ECharts and Java natures.
	 * @return the new IEChartsProject
	 * @throws EChartsModelException if the project could not be created.
	 */
    public static IEChartsProject newProject(IProject project) throws EChartsModelException {
        return newProject(project, false, false);
    }

    /**
	 * Create a new EChartsProject and JavaProject for the specified IProject.
	 * This is a convenience method to create a new project using defaults. This
	 * method invokes
	 * {@link #newProject(IProject, IEChartsPathEntry[], String[], IPath, IClasspathEntry[], IPath, boolean)}
	 * with appropriate default parameters.
	 * @param project The eclipse project which shall have the ECharts and Java natures.
	 * @param useJavaSrcDir boolean used to determine whether the ECharts source should go into the Java source directory or its own.
	 * @param isDK boolean <code>true</code> if this project represents a new Development Kit
	 * @return the new IEChartsProject
	 * @throws EChartsModelException if the project could not be created.
	 */
    public static IEChartsProject newProject(IProject project, boolean useJavaSrcDir, boolean isDK) throws EChartsModelException {
        IPath ech2java = project.getFullPath().addTrailingSeparator().append(new Path(getOption(ECHARTS_DEFAULT_OUT)));
        IPath javaBin = new Path("bin");
        return newProject(project, generateDefaultPath(project, useJavaSrcDir), new String[] {}, ech2java, EMPTY_CLASSPATH, javaBin, isDK);
    }

    /**
	 * Create a new EChartsProject and JavaProject for the specified IProject.
	 * 
	 * @param project
	 *            the IProject being converted to an eCharts Project
	 * @param rawClasspath
	 *            the classpath for the ECharts translator
	 * @param folders
	 *            Array of folder names for additional folders needed for the
	 *            project. This list should not include the folders referenced
	 *            by the classpathEntries or the default output paths.
	 * @param defaultOut
	 *            The root output directory where the ECharts translator should
	 *            place its Java files
	 * @param javaClasspath
	 *            Additional classpath entries outside of the JRE_CONTAINER, the
	 *            standard source directory, the echarts output directory, and
	 *            the echarts.jar.
	 * @param defaultJavaOut
	 *            Where the java compiler should put its .class files
	 * @param isDK boolean <code>true</code> if this project represents a new Development Kit
	 * @return the new IEChartsProject
	 * @throws EChartsModelException if the project could not be created.
	 */
    public static IEChartsProject newProject(IProject project, IEChartsPathEntry rawClasspath[], String folders[], IPath defaultOut, IClasspathEntry javaClasspath[], IPath defaultJavaOut, boolean isDK) throws EChartsModelException {
        IWorkspace wkspc = ResourcesPlugin.getWorkspace();
        IWorkspaceRoot wsRoot = wkspc.getRoot();
        createEChartsProject(project);
        createProjectFolders(project, folders);
        IPath javaOutput = project.getFullPath().addTrailingSeparator().append(defaultJavaOut);
        if (!defaultOut.isAbsolute()) {
            defaultOut = project.getFullPath().addTrailingSeparator().append(defaultOut);
        }
        ArrayList classpathEntries = createInitialJavaClassPath(wsRoot, project, defaultOut, javaOutput);
        if (javaClasspath != null) {
            for (int i = 0; i < javaClasspath.length; i++) {
                classpathEntries.add(javaClasspath[i]);
            }
        }
        addEChartsSrcToJavaPath(project, rawClasspath, classpathEntries);
        IEChartsProject eProject = null;
        try {
            IWorkspaceDescription wkspcDesc = wkspc.getDescription();
            boolean isAutoBuilding = wkspcDesc.isAutoBuilding();
            if (isAutoBuilding) {
                wkspcDesc.setAutoBuilding(false);
                wkspc.setDescription(wkspcDesc);
            }
            setUpProjectNatures(project, isDK);
            eProject = EChartsCore.create(project);
            EChartsModelManager.getEChartsModelManager().getEChartsModel().addProject(eProject);
            eProject.getJavaProject().setOutputLocation(javaOutput, null);
            eProject.getJavaProject().setRawClasspath((IClasspathEntry[]) classpathEntries.toArray(EMPTY_CLASSPATH), null);
            eProject.setRawClasspath(rawClasspath, defaultOut, null);
            if (isAutoBuilding) {
                wkspcDesc.setAutoBuilding(true);
                wkspc.setDescription(wkspcDesc);
            }
        } catch (JavaModelException e) {
            throw javaModelException("failed to setup java environment for " + project.getName(), e);
        } catch (CoreException e) {
            throw coreException("failed to set up project " + project.getName(), e);
        }
        return eProject;
    }

    /**
	 * @param project
	 * @param isDK
	 * @throws CoreException
	 */
    private static void setUpProjectNatures(IProject project, boolean isDK) throws CoreException {
        IProjectDescription idesc = project.getDescription();
        if (isDK) {
            idesc.setNatureIds(new String[] { EChartsCore.NATURE_ID, JavaCore.NATURE_ID, EChartsCore.DK_NATURE });
        } else {
            idesc.setNatureIds(new String[] { EChartsCore.NATURE_ID, JavaCore.NATURE_ID });
        }
        project.setDescription(idesc, null);
    }

    /**
	 * Create ECharts source folders and Java classpath entries from the raw classpath.
	 * @param project
	 * @param rawClasspath
	 * @param classpathEntries
	 * @throws EChartsModelException
	 */
    private static void addEChartsSrcToJavaPath(IProject project, IEChartsPathEntry[] rawClasspath, ArrayList classpathEntries) throws EChartsModelException {
        for (int i = 0; i < rawClasspath.length; i++) {
            if (rawClasspath[i].getEntryKind() == IEChartsPathEntry.CPE_SOURCE) {
                IFolder folder = ResourcesPlugin.getWorkspace().getRoot().getFolder(rawClasspath[i].getPath());
                EChartsCore.createFolder(folder, true, true, null);
                IPath out = rawClasspath[i].getOutputLocation();
                if (out != null) {
                    folder = getProjectFolder(project, out.toPortableString());
                    EChartsCore.createFolder(folder, true, true, null);
                    classpathEntries.add(JavaCore.newSourceEntry(project.getFullPath().addTrailingSeparator().append(out)));
                }
            }
        }
    }

    /**
	 * Create the initial Java Classpath based on default src and output information.
	 * @param wsRoot The workspace root to find folders.
	 * @param project The project for which the classpath is being built.
	 * @param defaultOut The default output of translated files.
	 * @param javaOutput The default output of <code>.class</code>files.
	 * @return ArrayList of IClasspathEntry
	 * @throws EChartsModelException
	 */
    private static ArrayList createInitialJavaClassPath(IWorkspaceRoot wsRoot, IProject project, IPath defaultOut, IPath javaOutput) throws EChartsModelException {
        ArrayList classpathEntries = new ArrayList();
        classpathEntries.add(JavaCore.newContainerEntry(new Path(JavaRuntime.JRE_CONTAINER)));
        IPath sourcePath = project.getFullPath().addTrailingSeparator().append("src");
        IFolder srcFolder = ResourcesPlugin.getWorkspace().getRoot().getFolder(sourcePath);
        IFolder outFolder = ResourcesPlugin.getWorkspace().getRoot().getFolder(javaOutput);
        EChartsCore.createFolder(srcFolder, true, true, null);
        EChartsCore.createFolder(outFolder, true, true, null);
        classpathEntries.add(JavaCore.newSourceEntry(sourcePath, new IPath[] { new Path("**/*.ech") }, javaOutput));
        EChartsCore.createFolder(wsRoot.getFolder(defaultOut), true, true, null);
        classpathEntries.add(JavaCore.newSourceEntry(defaultOut));
        classpathEntries.add(JavaCore.newContainerEntry(new Path(DK_CONTAINER_PATH)));
        return classpathEntries;
    }

    /**
	 * Create folders for the specified project.
	 * @param project the project in which the folders should be created.
	 * @param folders the set of folders to be created.
	 * @throws EChartsModelException if the folders specified cannot be created
	 */
    private static void createProjectFolders(IProject project, String[] folders) throws EChartsModelException {
        for (int i = 0; i < folders.length; i++) {
            IFolder folder = getProjectFolder(project, folders[i]);
            EChartsCore.createFolder(folder, true, true, null);
        }
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            getExceptionStatus("Thread.sleep", e);
        }
    }

    /**
	 * Create an ECharts project from an IProject
	 * @param project the project to be created.
	 * @throws EChartsModelException if the project already has an ECharts nature
	 */
    private static void createEChartsProject(IProject project) throws EChartsModelException {
        try {
            if (project.exists() && project.hasNature(EChartsCore.NATURE_ID)) throw elementExistsException(project.getName());
            if (!project.exists()) project.create(null);
            if (!project.isOpen()) project.open(null);
        } catch (CoreException e1) {
            throw coreException("checking project " + project.getName(), e1);
        }
    }

    /**
	 * Convenience method to delete the project. Calls
	 * <code>project.delete(true, null)</code>
	 * 
	 * @param project
	 *            The project to be deleted.
	 * @throws EChartsModelException
	 */
    public static void removeProject(IProject project) throws EChartsModelException {
        try {
            project.delete(true, null);
        } catch (CoreException e) {
            throw coreException("cannot delete project " + project.getName(), e);
        }
    }

    /**
	 * Utility method that locates the desired folder within the specified
	 * project.
	 * 
	 * @param project
	 *            The project containing the desired folder.
	 * @param name
	 *            a String containing the project relative path of the desired
	 *            folder.
	 * @return the IFolder representing the desired project relative folder.
	 */
    public static IFolder getProjectFolder(IProject project, String name) {
        IPath dir = project.getFullPath().addTrailingSeparator().append(new Path(name));
        IFolder folder = ResourcesPlugin.getWorkspace().getRoot().getFolder(dir);
        return folder;
    }

    /**
	 * Utility method used to initialize a Java classpath variable whose value
	 * is the location of the bundle.
	 * 
	 * @param bundle
	 *            The bundle whose location is desired.
	 * @param variable
	 *            The name of the variable.
	 * @throws EChartsModelException 
	 */
    public static void initializeClasspathVariable(Bundle bundle, String variable) throws EChartsModelException {
        URL result = FileLocator.find(bundle, new Path(""), null);
        try {
            result = FileLocator.resolve(result);
            IPath pluginLoc = new Path(result.getFile());
            JavaCore.setClasspathVariable(variable, pluginLoc, null);
        } catch (IOException e) {
            throw badClassPathException("EChartsCore failed to get plugin location for " + bundle.getBundleId(), e);
        } catch (JavaModelException e) {
            throw javaModelException("Can't create variable " + variable + " with JavaCore", e);
        }
    }

    /**
	 * Sets the specified preference option.
	 * @param optionName String the name of the option to be set.
	 * @param optionValue String the value of the option to be set.
	 */
    public static void setOption(String optionName, String optionValue) {
        modelManager.getInstancePrefs().put(optionName, optionValue);
    }

    /**
	 * Get a Development Kit by name.
	 * @param dkName String the name of the Development Kit.
	 * @return IDevelopmentKit The Development Kit with the specified name.
	 * @throws CoreException if the list of DKs could not be determined.
	 */
    public IDevelopmentKit getDK(String dkName) throws CoreException {
        if (dkMap == null) {
            buildDKMap();
        }
        IDevelopmentKit ret = (IDevelopmentKit) dkMap.get(dkName);
        if (ret == null) {
            ret = (IDevelopmentKit) dkMap.get(dkName + "(1)");
        }
        return ret;
    }

    /**
	 * Build the map of DKs from the known list stored in the state location.
     * If the store does not exist, create it and load it with the default
     * DK located within the plugin.
	 * @throws CoreException if the store cannot be created or parsed.
	 */
    private void buildDKMap() throws CoreException {
        dkMap = new HashMap();
        File dkStore = getStateLocation().addTrailingSeparator().append("dk.xml").toFile();
        if (!dkStore.exists()) {
            try {
                if (!dkStore.createNewFile()) {
                    throw new CoreException(getErrorStatus("Could not create development kit storage"));
                }
                importDK(createDK(getPluginDK()));
            } catch (IOException e) {
                throw new CoreException(getExceptionStatus("Could not create development kit storage", e));
            }
        } else {
            try {
                Document dkDoc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(dkStore);
                Element dkRoot = dkDoc.getDocumentElement();
                NodeList dkList = dkRoot.getElementsByTagName("dk");
                for (int i = 0, length = dkList.getLength(); i < length; i++) {
                    Element dk = (Element) dkList.item(i);
                    String name = dk.getAttribute("name");
                    String loc = dk.getAttribute("location");
                    String version = dk.getAttribute("version");
                    if (version.length() == 0) version = "1";
                    String dkClass = dk.getAttribute("class");
                    try {
                        BaseDevelopmentKit newDK = (BaseDevelopmentKit) Class.forName(dkClass).newInstance();
                        newDK.setDK(new Path(loc), name, version);
                        dkMap.put(newDK.getKey(), newDK);
                    } catch (InstantiationException e) {
                        getExceptionStatus("Error trying to create DK: " + name, e);
                    } catch (IllegalAccessException e) {
                        getExceptionStatus("Error trying to create DK: " + name, e);
                    } catch (ClassNotFoundException e) {
                        getExceptionStatus("Error trying to create DK: " + name, e);
                    }
                }
            } catch (SAXException e) {
                throw new CoreException(getExceptionStatus("Cannot create DK Map", e));
            } catch (IOException e) {
                throw new CoreException(getExceptionStatus("Cannot create DK Map", e));
            } catch (ParserConfigurationException e) {
                throw new CoreException(getExceptionStatus("Cannot create DK Map", e));
            }
        }
        IEChartsProject projects[] = getEChartsModel().getEChartsProjects();
        for (int i = 0; i < projects.length; i++) {
            if (projects[i].getProject().hasNature(DK_NATURE)) {
                IDevelopmentKit dk = new EChartsDKProject(projects[i]);
                dkMap.put(dk.getName(), dk);
            }
        }
    }

    /**
	 * Get the location of the internal DK.
	 * @return IPath The path to the plugin + "dk"
	 * @throws CoreException if the path to the plugin cannot be determined.
	 */
    private IPath getPluginDK() throws CoreException {
        Bundle edtCoreBundle = getBundle();
        URL result = FileLocator.find(edtCoreBundle, new Path("dk"), null);
        try {
            result = FileLocator.resolve(result);
            return new Path(result.getFile());
        } catch (IOException e) {
            throw new CoreException(getExceptionStatus("Could not get path for default DK", e));
        }
    }

    /**
	 * Unzip the DK archive file and create the appropriate DK class.  The 
     * zip file will be loaded into a directory in the state location and the
     * path to the newly created directory will be set to this location.
     * The method can use zip files that have a single top-level directory
     * containing the DK or the DK itself.  That is, once the zip file is loaded,
     * the <code>dk.xml</code> file can exist in the resulting directory, or the
     * resulting directory can have exactly one directory which contains the
     * <code>dk.xml</code> file.
	 * @param loc String the location of the <code>.zip</code> file.
	 * @param monitor IProgressMonitor monitor to track the unzipping process.
	 * @return IDevelopmentKit the development kit that handles the DK.
	 * @throws CoreException if the zip file is corrupt or if the zip file does
     * not contain an appropriate <code>dk.xml</code> file.
	 */
    public IDevelopmentKit unzipDK(String loc, IProgressMonitor monitor) throws CoreException {
        try {
            ZipFile zf = new ZipFile(loc);
            IPath dkDir = getStateLocation().addTrailingSeparator().append("importedDKs");
            File dkDirFile = dkDir.toFile();
            if (!dkDirFile.exists()) {
                dkDirFile.mkdir();
            }
            File dkLocFile = File.createTempFile("edk", "", dkDirFile);
            dkLocFile.delete();
            IPath dkLoc = new Path(dkLocFile.getAbsolutePath());
            dkLocFile.mkdir();
            unzip(zf, dkLocFile, (monitor == null) ? new NullProgressMonitor() : monitor);
            IPath translator = dkLoc.addTrailingSeparator().append(new Path("bin/ech2java"));
            if (translator.toFile().exists()) {
                return createDK(dkLoc);
            }
            String[] subDirs = dkLocFile.list();
            if (subDirs.length == 1) {
                dkLoc = dkLoc.addTrailingSeparator().append(subDirs[0]);
                translator = dkLoc.addTrailingSeparator().append(new Path("bin/ech2java"));
                if (translator.toFile().exists()) {
                    return createDK(dkLoc);
                }
            }
            throw new CoreException(getErrorStatus("zip file did not contain translator: " + loc));
        } catch (IOException e) {
            throw new CoreException(getExceptionStatus("Could not unzip development kit: " + loc, e));
        }
    }

    /**
	 * Unzip a zipfile into a target location.
	 * @param zf ZipFile the zip file.
	 * @param target File the target location.
	 * @param monitor IProgressMonitor a monitor to track the progress of unzipping.
	 */
    private static void unzip(ZipFile zf, File target, IProgressMonitor monitor) {
        monitor.beginTask("Processing " + zf.getName(), zf.size());
        Enumeration ent = zf.entries();
        while (ent.hasMoreElements()) {
            InputStream is = null;
            OutputStream os = null;
            try {
                ZipEntry entry = (ZipEntry) ent.nextElement();
                if (entry.isDirectory()) {
                    new File(target, entry.getName()).mkdirs();
                } else {
                    File targetFile = new File(target, entry.getName());
                    is = zf.getInputStream(entry);
                    os = new FileOutputStream(targetFile);
                    int b = 0;
                    while ((b = is.read()) != -1) {
                        os.write(b);
                    }
                }
            } catch (FileNotFoundException e) {
                getExceptionStatus("Error trying to unzip " + zf.getName(), e);
            } catch (IOException e) {
                getExceptionStatus("Error trying to unzip " + zf.getName(), e);
            } finally {
                try {
                    if (os != null) {
                        os.flush();
                        os.close();
                    }
                    if (is != null) {
                        is.close();
                    }
                } catch (IOException e) {
                    getExceptionStatus("Error trying to close files while unzipping " + zf.getName(), e);
                }
            }
            monitor.worked(1);
        }
        monitor.done();
    }

    /**
	 * Create an IDevelopmentKit for the specified path.
	 * @param dkPath IPath The path to the desired DK.
	 * @return IDevelopmentKit the development kit that handles the DK.
	 * @throws CoreException
	 */
    public static IDevelopmentKit createDK(IPath dkPath) throws CoreException {
        IDevelopmentKit dk = EChartsDevelopmentKitFactory.getDevelopmentKit(dkPath);
        return dk;
    }

    /**
	 * Add an IDevelopmentKit to the map and store it for permenant use.
	 * @param dk IDevelopmentKit the DK to import
	 * @throws CoreException if the store cannot be updated.
	 */
    public void importDK(IDevelopmentKit dk) throws CoreException {
        dkMap.put(dk.getKey(), dk);
        saveDKFile();
    }

    /**
	 * Store the DK map in the store location.  The map is stored in an XML format.
	 * @throws CoreException if the store cannot be updated.
	 */
    private void saveDKFile() throws CoreException {
        File dkStore = getStateLocation().addTrailingSeparator().append("dk.xml").toFile();
        String ls = System.getProperty("line.separator");
        FileWriter fw = null;
        try {
            fw = new FileWriter(dkStore);
            fw.write("<?xml version=\"1.0\"?>" + ls);
            fw.write("<dkList>" + ls);
            Iterator it = dkMap.values().iterator();
            while (it.hasNext()) {
                IDevelopmentKit val = (IDevelopmentKit) it.next();
                fw.write("\t<dk name=\"");
                fw.write(val.getName());
                fw.write("\" version=\"");
                fw.write(val.getVersion());
                fw.write("\" class=\"");
                fw.write(val.getClass().getName());
                fw.write("\" location=\"");
                fw.write(val.getLocation().toPortableString());
                fw.write("\"/>" + ls);
            }
            fw.write("</dkList>" + ls);
        } catch (IOException e) {
            throw new CoreException(getExceptionStatus("Could not save development kit list", e));
        } finally {
            try {
                fw.flush();
                fw.close();
            } catch (IOException e) {
                throw new CoreException(getExceptionStatus("Could not save development kit list", e));
            }
        }
    }

    /**
	 * Adds the specified project as a DK
	 * @param dk EChartsDKProject
	 * @throws EChartsModelException if the initial DK map cannot be created.
	 */
    public void newProjectDK(EChartsDKProject dk) throws EChartsModelException {
        if (dkMap == null) {
            try {
                buildDKMap();
            } catch (CoreException e) {
                throw coreException("Can't build DK map", e);
            }
        }
        dkMap.put(dk.getName(), dk);
    }

    /**
	 * Remove the specified project as a development kit.
	 * @param dk EChartsDKProject
	 */
    public void removeProjectDK(EChartsDKProject dk) {
        dkMap.remove(dk.getName());
    }

    /**
	 * Retrieve the entire set of DKs
	 * @return Collection all known DKs
	 * @throws CoreException when the initialization of the map fails.
	 */
    public Collection getAllDKs() throws CoreException {
        if (dkMap == null) {
            buildDKMap();
        }
        return dkMap.values();
    }

    /**
	 * Get the PathContainer specified by the given path for the specified project.
	 * @param path IPath the path of the container
	 * @param project IEChartsProject the project for which the container is desired.
	 * @return IEChartsPathContainer the path container for the specified project.
	 * @throws EChartsModelException if the path is for the DK and the DK retrieval fails or
     * if the path pertains to an unknown container.
	 */
    public static IEChartsPathContainer getEChartsPathContainer(IPath path, IEChartsProject project) throws EChartsModelException {
        if (path.toString().equals(DK_CONTAINER_PATH)) {
            try {
                return project.getDK();
            } catch (CoreException e) {
                throw coreException("Error getting DK", e);
            }
        }
        throw badClassPathException("No such container " + path.toPortableString());
    }

    /**
	 * This method sets the PathContainer for the specified path
	 * for the projects and containers.
	 * @param path The path for the specified container
	 * @param projects The projects to be updated.
	 * @param containers The containers that correspond to the specified path
	 * @param monitor a progress monitor.
	 * @throws EChartsModelException 
	 */
    public static void setEChartsPathContainer(IPath path, IEChartsProject[] projects, IEChartsPathContainer[] containers, IProgressMonitor monitor) throws EChartsModelException {
    }

    /**
	 * Deletes the directory created for a DK that was imported from a zip file.
	 * @param dk IDevelopmentKit the DK that was created from an imported zip file.
	 */
    public void deleteLocalDK(IDevelopmentKit dk) {
        IPath stateLoc = getStateLocation();
        if (stateLoc.isPrefixOf(dk.getLocation())) {
            IPath dirLoc = stateLoc.addTrailingSeparator().append("importedDKs");
            IPath relDkLoc = dk.getLocation().removeFirstSegments(dirLoc.segmentCount());
            dirLoc = dirLoc.addTrailingSeparator().append(relDkLoc.uptoSegment(1));
            delete(dirLoc.toFile());
        }
    }

    /**
	 * Recursively delete a file.
	 * @param file File to be deleted.
	 */
    private void delete(File file) {
        if (file.isDirectory()) {
            File files[] = file.listFiles();
            for (int i = 0; i < files.length; i++) {
                delete(files[i]);
            }
        }
        file.delete();
    }

    /**
	 * Get the DK specified by the default option.  If the default specifies
     * a DK that does not exist, then ask for the DK that comes with the plugin.
     * If the default doesn't exist and the one that comes with the plugin has
     * been deleted, then recreate the one that comes with the plugin and return it.
	 * @return IDevelopmentKit the default DK.
	 * @throws CoreException if there are issues with the DK store.
	 */
    public IDevelopmentKit getDefaultDK() throws CoreException {
        String dkName = getOption(ECHARTS_DEFAULT_DK);
        IDevelopmentKit dk = getDK(dkName);
        if (dk != null) {
            return dk;
        }
        dk = getDK("core");
        if (dk == null) {
            dk = createDK(getPluginDK());
            importDK(dk);
        }
        modelManager.setOption(ECHARTS_DEFAULT_DK, dk.getName());
        return dk;
    }

    /**
	 * Remove the specified DK from the map.  For any projects that were assigned
     * the specified DK, reset them to use the default DK.
	 * @param dk IDevelopmentKit the DK to be removed.
	 * @throws CoreException if the updated map cannot be stored or if there
     * are issues with resetting a project's DK.
	 */
    public void removeDK(IDevelopmentKit dk) throws CoreException {
        if (dkMap.remove(dk.getName()) != null) {
            saveDKFile();
            deleteLocalDK(dk);
            IDevelopmentKit defDK = getDefaultDK();
            IEChartsProject projects[] = getEChartsModel().getEChartsProjects();
            for (int i = 0; i < projects.length; i++) {
                if (projects[i].getDK() == null) projects[i].setDK(defDK);
            }
        }
    }

    /**
	 * Convenience method to create an IStatus to be used in throwing
     * a CoreException.  The status will be logged.
	 * @param message String reason for the error.
	 * @param e Throwable The exception that caused the error.
	 * @return IStatus
	 */
    public static IStatus getExceptionStatus(String message, Throwable e) {
        return new EChartsModelStatus(IStatus.ERROR, 0, message, e);
    }

    /**
	 * Convenience method to create an IStatus to be used in throwing
     * a CoreException.  The status will be logged.
	 * @param message String reason for the error.
	 * @return IStatus
	 */
    public static IStatus getErrorStatus(String message) {
        return new EChartsModelStatus(IStatus.ERROR, 0, message);
    }

    /**
	 * Convenience method to create an EChartsModelException with a bad classpath code
	 * and the specified message.
	 * @param message String Error text.
	 * @return EChartsModelException
	 */
    public static EChartsModelException badClassPathException(String message) {
        return new EChartsModelException(new EChartsModelStatus(IStatus.ERROR, IEChartsModelStatus.ECHARTS_PATH_ERROR, message));
    }

    /**
	 * Convenience method to create an EChartsModelException with a bad classpath code
	 * and the specified message that was caused by the specified exception.
	 * @param message String Error text.
	 * @param exception Throwable The exception that caused the error.
	 * @return EChartsModelException
	 */
    public static EChartsModelException badClassPathException(String message, Throwable exception) {
        return new EChartsModelException(new EChartsModelStatus(IStatus.ERROR, IEChartsModelStatus.ECHARTS_PATH_ERROR, message, exception));
    }

    /**
	 * Convenience method to create an EChartsModelException with a bad element name code
	 * and the specified message.
	 * @param message String Error text.
	 * @return EChartsModelException
	 */
    public static EChartsModelException badElementNameException(String message) {
        return new EChartsModelException(new EChartsModelStatus(IStatus.ERROR, IEChartsModelStatus.ECHARTS_INVALID_NAME, message));
    }

    /**
	 * Convenience method to create an EChartsModelException with an invalid contents code
	 * and the specified message.
	 * @param message String Error text.
	 * @return EChartsModelException
	 */
    public static EChartsModelException badContentsException(String message) {
        return new EChartsModelException(new EChartsModelStatus(IStatus.ERROR, IEChartsModelStatus.ECHARTS_INVALID_CONTENTS, message));
    }

    /**
	 * Convenience method to create an EChartsModelException with an element exists code
	 * and the specified message.
	 * @param message String Error text.
	 * @return EChartsModelException
	 */
    public static EChartsModelException elementExistsException(String message) {
        return new EChartsModelException(new EChartsModelStatus(IStatus.ERROR, IEChartsModelStatus.ECHARTS_ELEMENT_EXISTS, message));
    }

    /**
	 * Convenience method to create an EChartsModelException with an element exists code
	 * and the specified message.
	 * @param message String Error text.
	 * @return EChartsModelException
	 */
    public static EChartsModelException noSuchElementException(String message) {
        return new EChartsModelException(new EChartsModelStatus(IStatus.ERROR, IEChartsModelStatus.ECHARTS_NO_SUCH_ELEMENT, message));
    }

    /**
	 * Convenience method to create an EChartsModelException with a core exception code
	 * and the specified message.
	 * @param message String Error text.
	 * @param exception CoreException The exception that caused the error.
	 * @return EChartsModelException
	 */
    public static EChartsModelException coreException(String message, CoreException exception) {
        return new EChartsModelException(new EChartsModelStatus(IStatus.ERROR, IEChartsModelStatus.ECHARTS_CORE_EXCEPTION, message, exception));
    }

    /**
	 * Convenience method to create an EChartsModelException with a JavaModelException code
	 * and the specified message.
	 * @param message String Error text.
	 * @param exception JavaModelException The exception that caused the error.
	 * @return EChartsModelException
	 */
    public static EChartsModelException javaModelException(String message, JavaModelException exception) {
        return new EChartsModelException(new EChartsModelStatus(IStatus.ERROR, IEChartsModelStatus.ECHARTS_JAVAMODEL_EXCEPTION, message, exception));
    }

    /**
	 * Method unsupportedDK.
	 * @param message String
	 * @return IStatus
	 */
    public static EChartsModelException unsupportedDK(String message) {
        return new EChartsModelException(new EChartsModelStatus(IStatus.ERROR, IEChartsModelStatus.UNSUPPORTED_DK_VERSION, message, null));
    }

    /**
	 * Method invalidDK.
	 * @param message String
	 * @param e Throwable
	 * @return IStatus
	 */
    public static EChartsModelException invalidDK(String message, Throwable e) {
        return new EChartsModelException(new EChartsModelStatus(IStatus.ERROR, IEChartsModelStatus.INVALID_DK, message, e));
    }

    /**
	 * Method uninitializedElement.
	 * @param message String
	 * @param e Throwable
	 * @return IStatus
	 */
    public static EChartsModelException uninitializedElement(String message) {
        return new EChartsModelException(new EChartsModelStatus(IStatus.ERROR, IEChartsModelStatus.UNINITIALIZED_ELEMENT, message, null));
    }
}
