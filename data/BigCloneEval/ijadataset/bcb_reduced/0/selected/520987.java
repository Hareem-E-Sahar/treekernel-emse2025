package com.koutra.dist.proc.sink;

import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.Reader;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import org.apache.log4j.Logger;
import com.koutra.dist.proc.model.ContentType;
import com.koutra.dist.proc.model.IFaucet;
import com.koutra.dist.proc.model.IPipelineItem;
import com.koutra.dist.proc.model.XformationException;

/**
 * A writer zip mux sink consumes a sequence of character streams generated by a
 * template item and stores them into a zip file with a single zip file entry for
 * each individual character stream. The user specifies the file in their local
 * file system and the character set encoding to use.
 *
 * @author Pafsanias Ftakas
 */
public class WriterZipMuxSink extends AbstractFileOrStreamMuxSink {

    private static final Logger logger = Logger.getLogger(WriterZipMuxSink.class);

    protected static class DequePayload {

        public IFaucet faucet;

        public Reader reader;

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof DequePayload)) return false;
            DequePayload other = (DequePayload) obj;
            if (reader == null && other.reader != null) return false;
            return faucet.equals(other.faucet) && reader.equals(other.reader);
        }
    }

    protected BlockingDeque<DequePayload> deque;

    protected String charset;

    protected ZipOutputStream outputStream;

    /**
	 * @deprecated Use any of the initializing constructors instead.
	 */
    public WriterZipMuxSink() {
    }

    /**
	 * Initializing constructor for the Stream type.
	 * @param id the ID of the sink.
	 * @param os the output stream to write to.
	 */
    public WriterZipMuxSink(String id, String charset, ZipOutputStream os) {
        super(id);
        this.deque = new LinkedBlockingDeque<DequePayload>();
        this.charset = charset;
        this.outputStream = os;
    }

    /**
	 * Initializing constructor for the File type.
	 * @param id the ID of the sink.
	 * @param path the path to the file to write to.
	 */
    public WriterZipMuxSink(String id, String charset, String path) {
        super(id, path);
        this.deque = new LinkedBlockingDeque<DequePayload>();
        this.charset = charset;
        this.outputStream = null;
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 * 
	 * @param contentType the type that we want this sink to support.
	 * @return true iff this sink supports the content type argument.
	 */
    @Override
    public boolean supportsInput(ContentType contentType) {
        switch(contentType) {
            case CharStream:
                return true;
            case ByteStream:
            case XML:
            case ResultSet:
            default:
                return false;
        }
    }

    /**
	 * Override the implementation in the abstract sink to add a check that the faucet
	 * supports the proper content type.
	 */
    @Override
    protected void checkFaucetValidity(IFaucet faucet) {
        super.checkFaucetValidity(faucet);
        if (!faucet.supportsOutput(ContentType.CharStream)) throw new IllegalArgumentException("Faucet '" + faucet.getId() + "' must support the CharStream content type.");
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 */
    @Override
    public void registerSource(Object source) {
        Reader reader = (Reader) source;
        DequePayload payload = new DequePayload();
        payload.faucet = faucet;
        payload.reader = reader;
        if (deque.contains(payload)) return;
        if (logger.isTraceEnabled()) logger.trace("Registering reader: " + reader + " with the mux deque");
        while (true) {
            try {
                deque.putLast(payload);
                break;
            } catch (InterruptedException e) {
            }
        }
        if (reader != null) {
            if (faucet instanceof IPipelineItem) {
                ((IPipelineItem) faucet).consume(this);
            }
        }
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 */
    @Override
    public String dumpPipeline() {
        DequePayload payload = deque.peekFirst();
        return getClass().getName() + ": " + (payload == null ? "null" : payload.reader) + "->" + outputStream;
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 */
    @Override
    public void dispose() {
        switch(type) {
            case File:
                try {
                    outputStream.close();
                } catch (IOException e) {
                    throw new XformationException("Unable to close output stream", e);
                }
                break;
            case Stream:
                break;
        }
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 */
    @Override
    public void consume() {
        if (!hookedUp && faucetTemplate == null) throw new XformationException("Sink has not been set up correctly: " + "faucet has not been set");
        switch(type) {
            case File:
                try {
                    outputStream = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(path)));
                } catch (FileNotFoundException e) {
                    throw new XformationException("Unable to create output stream", e);
                }
                break;
            case Stream:
                break;
        }
        if (!hookedUp) {
            if (faucetTemplate instanceof IPipelineItem) {
                ((IPipelineItem) faucetTemplate).consume(this);
            }
        }
        try {
            int count;
            char[] buffer = new char[8 * 1024];
            int counter = 0;
            while (true) {
                DequePayload payload = null;
                try {
                    payload = deque.takeFirst();
                } catch (InterruptedException ie) {
                }
                if (payload == null) break;
                IFaucet faucet = payload.faucet;
                Reader reader = payload.reader;
                if (logger.isTraceEnabled()) logger.trace("Removed reader: " + reader + " from the deque.");
                if (reader == null) break;
                if (logger.isTraceEnabled()) logger.trace("Using the reader " + reader + " in the mux sink");
                ZipEntry entry = new ZipEntry("entry" + counter++);
                outputStream.putNextEntry(entry);
                while ((count = reader.read(buffer)) != -1) {
                    String readInput = new String(buffer, 0, count);
                    if (logger.isTraceEnabled()) {
                        logger.trace("Read " + readInput + " from reader " + reader);
                    }
                    byte[] actualBytes = readInput.getBytes(charset);
                    outputStream.write(actualBytes, 0, actualBytes.length);
                }
                outputStream.closeEntry();
                faucet.dispose();
            }
            outputStream.close();
            faucetTemplate.dispose();
        } catch (IOException ioe) {
            logger.error("Error while consuming input", ioe);
            throw new XformationException("Unable to transform stream", ioe);
        }
    }

    /**
	 * Override the <code>Streamable</code> implementation in order to deserialize
	 * local members.
	 */
    @Override
    public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {
        super.readFrom(in);
        this.deque = new LinkedBlockingDeque<DequePayload>();
        this.outputStream = null;
        this.charset = in.readUTF();
    }

    /**
	 * Override the <code>Streamable</code> implementation in order to serialize
	 * local members.
	 */
    @Override
    public void writeTo(DataOutputStream out) throws IOException {
        super.writeTo(out);
        out.writeUTF(charset);
    }
}
