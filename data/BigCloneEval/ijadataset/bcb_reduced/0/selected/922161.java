package oscript.swing.text;

import oscript.data.*;
import oscript.syntaxtree.NodeToken;
import java.util.*;
import java.awt.Graphics;
import java.awt.Color;
import java.awt.Font;
import javax.swing.text.*;
import javax.swing.event.*;

/**
 * An editor-kit for an ObjectScript src code editor.  The document used is just
 * a plain-old {@link PlainDocument}.  Rather than trying to integrate the 
 * parser with the {@link Document}'s {@link Element} structure, the parsed
 * representation of the document is stored seperately as an array of tokens.
 * We create a {@link View} for rendering the document that takes into account
 * the token that overlays a section of text, and the {@link AttributeSet}
 * which that token maps to, as it renders the text.
 * <p>
 * For performance reasons, parsing happens asynchronously, which means that
 * whenever the document is mutated.  So, when there is an insert, we update
 * the (now out of date) tokens by increasing the end-offset of the current
 * token, and the begin-offset and end-offset of all subsequent tokens by the
 * number of characters inserted.  When there is a remove, the process is 
 * essentially the reverse.
 * <p>
 * The script side of things handles creating the parsing thread, and it uses
 * {@link DocumentListener}s to determine when reparsing is needed.
 * 
 * @author Rob Clark (rob@ti.com)
 * <!--$Format: " * @version $Revision$"$-->
 * @version 1.10
 * @see #createDefaultDocument
 */
public class ObjectScriptEditorKit extends DefaultEditorKit {

    public static final int search(String str, int off, int start, int end, Document doc, int inc) {
        try {
            return search(str, off, start, end, doc.getText(0, doc.getLength()), inc);
        } catch (BadLocationException e) {
            e.printStackTrace();
            return -1;
        }
    }

    public static final int search(String str, int off, int start, int end, String data, int inc) {
        int slen = str.length();
        while ((start <= off) && (off < (end - slen))) {
            if (str.equals(data.substring(off, off + slen))) return off;
            off += inc;
        }
        return -1;
    }

    public static final int search(String[] strs, int off, int start, int end, Document doc, int inc) {
        try {
            return search(strs, off, start, end, doc.getText(0, doc.getLength()), inc);
        } catch (BadLocationException e) {
            e.printStackTrace();
            return -1;
        }
    }

    public static final int search(String[] strs, int off, int start, int end, String data, int inc) {
        int dlen = data.length();
        while ((start <= off) && (off < end)) {
            for (int i = 0; i < strs.length; i++) if (strs[i].equals(data.substring(off, off + strs[i].length()))) return off;
            off += inc;
        }
        return -1;
    }

    private Hashtable attrSetTable;

    private NodeToken[] nodeTokens = new NodeToken[0];

    /**
   * Class Constructor.
   * 
   * @param attrSetTable the table that maps NodeToken.kind to an attribute
   *    set.  This table is created and maintained from script code, but
   *    used here while rendering the text.
   */
    public ObjectScriptEditorKit(Hashtable attrSetTable) {
        this.attrSetTable = attrSetTable;
    }

    /**
   * Called from script code after parsing is completed.  For performance
   * reasons the tokens are stored here, after they are generated by script.
   */
    public synchronized void setNodeTokens(Vector v) {
        NodeToken[] newNodeTokens = new NodeToken[v.size()];
        v.copyInto(newNodeTokens);
        nodeTokens = newNodeTokens;
    }

    /**
   * Get a factory for producing {@link View}s for rendering {@link Document}s
   * created by this editor-kit.
   * 
   * @return the view-factory
   */
    public ViewFactory getViewFactory() {
        return new ViewFactory() {

            public View create(Element elem) {
                return new NodeTokenView(elem);
            }
        };
    }

    /**
   * Create a uninitialized document.  The {@link Document} used by this editor
   * kit is basically just a {@link PlainDocument} that has been extended to
   * synchronously update the offsets of the tokens in response to document
   * mutations (insert/remove).  This is important to ensure that the token's
   * offset maps to sensible positions in the document during the period between
   * when the document is edited, and when the parser has finished re-parsing it
   * 
   * @return an unitialized document
   */
    public Document createDefaultDocument() {
        return new ObjectScriptDocument();
    }

    public class ObjectScriptDocument extends PlainDocument {

        private long lastMutateTime;

        public long getLastMutateTime() {
            return lastMutateTime;
        }

        /**
     * Get a reader that returns the contents of this document
     */
        public java.io.Reader getDocumentReader() {
            return new java.io.Reader() {

                private int idx = 0;

                public int read(char[] cbuf, int off, int len) throws java.io.IOException {
                    try {
                        len = Math.min(len, getLength() - idx);
                        len = Math.min(len, 128);
                        System.arraycopy(getText(idx, len).toCharArray(), 0, cbuf, off, len);
                        idx += len;
                        if (len == 0) return -1;
                        return len;
                    } catch (BadLocationException e) {
                        throw new java.io.IOException("bad location: " + e.getMessage());
                    }
                }

                public void close() {
                }
            };
        }

        public void remove(int off, int len) throws BadLocationException {
            synchronized (ObjectScriptEditorKit.this) {
                lastMutateTime = System.currentTimeMillis();
                off = Math.max(off, 0);
                len = Math.min(off + len, getLength()) - off;
                updateRemove(off, len);
                super.remove(off, len);
            }
        }

        public void insertString(int off, String str, AttributeSet a) throws BadLocationException {
            synchronized (ObjectScriptEditorKit.this) {
                lastMutateTime = System.currentTimeMillis();
                updateInsert(off, str.length());
                super.insertString(off, str, a);
            }
        }
    }

    private synchronized void updateInsert(int off, int len) {
        NodeToken nt = getToken(off);
        if (nt != null) {
            LinkedList tokenList = new LinkedList();
            tokenList.add(nt);
            while ((nt = getToken(nt.endOffset + 1)) != null) tokenList.add(nt);
            Iterator itr = tokenList.iterator();
            ((NodeToken) (itr.next())).endOffset += len;
            while (itr.hasNext()) {
                nt = (NodeToken) (itr.next());
                nt.beginOffset += len;
                nt.endOffset += len;
            }
        }
    }

    private final synchronized void updateRemove(int off, int len) {
        NodeToken nt = getToken(off - len);
        if (nt != null) {
            int totalSub = 0;
            LinkedList tokenList = new LinkedList();
            tokenList.add(nt);
            while ((nt = getToken(nt.endOffset + 1)) != null) tokenList.add(nt);
            for (Iterator itr = tokenList.iterator(); itr.hasNext(); ) {
                nt = (NodeToken) (itr.next());
                int sub = len - Math.max(0, off + len - nt.endOffset);
                len -= sub;
                off += sub;
                nt.beginOffset -= totalSub;
                totalSub += sub;
                nt.endOffset -= totalSub;
            }
        }
    }

    /**
   * The {@link View} implementation.  Basically just a {@link PlainView} that 
   * changes the attribute-set for different node tokens within the view as it 
   * renders.
   */
    private class NodeTokenView extends PlainView {

        private Segment text = new Segment();

        /**
     * Class Constructor.
     */
        NodeTokenView(Element elem) {
            super(elem);
        }

        /**
     * Renders the given range in the model as normal unselected
     * text.  Uses the foreground or disabled color to render the text.
     *
     * @param g the graphics context
     * @param x the starting X coordinate >= 0
     * @param y the starting Y coordinate >= 0
     * @param p0 the beginning position in the model >= 0
     * @param p1 the ending position in the model >= 0
     * @returns the X location of the end of the range >= 0
     * @exception BadLocationException if the range is invalid
     */
        protected int drawUnselectedText(Graphics g, int x, int y, int p0, int p1) throws BadLocationException {
            if ((nodeTokens == null) || (nodeTokens.length == 0)) return super.drawUnselectedText(g, x, y, p0, p1);
            Document doc = getDocument();
            int p = p0;
            int kind = -1;
            while (p < p1) {
                NodeToken nt = getToken(p);
                int mark;
                if (nt == null) {
                    setKind(g, -1);
                    mark = p1;
                } else {
                    setKind(g, kind = nt.kind);
                    mark = Math.min(nt.endOffset + 1, p1);
                }
                if (mark > p) {
                    doc.getText(p, mark - p, text);
                    x = Utilities.drawTabbedText(text, x, y, g, this, mark);
                }
                p = mark;
            }
            return x;
        }

        private void setKind(Graphics g, int kind) {
            AttributeSet attrSet = (AttributeSet) (attrSetTable.get(new Integer(kind)));
            g.setColor(getFgColor(attrSet));
            g.setFont(getFont(g.getFont(), attrSet));
        }
    }

    private static Color defaultFgColor = Color.black;

    public static void setDefaultFgColor(Color c) {
        defaultFgColor = c;
    }

    private static Color getFgColor(AttributeSet attrSet) {
        Color c = null;
        if (attrSet != null) c = (Color) (attrSet.getAttribute(StyleConstants.Foreground));
        if (c == null) c = defaultFgColor;
        return c;
    }

    private static Font getFont(Font origFont, AttributeSet attrSet) {
        int style = Font.PLAIN;
        if (attrSet != null) {
            Integer val = (Integer) (attrSet.getAttribute("style"));
            if (val != null) style = val.intValue();
        }
        if (origFont.getStyle() == style) return origFont;
        return origFont.deriveFont(style);
    }

    /**
   * Given an offset into the document, find the corresponding token.
   * This is the API used by everything else for accessing the tokens.
   * The remaining methods are just used to implement this method.
   * 
   * @param off          the offset into the document
   */
    public synchronized NodeToken getToken(int off) {
        if ((0 <= idx) && (idx < nodeTokens.length)) {
            if (off >= nodeTokens[idx].getActualBeginOffset()) {
                if (off <= nodeTokens[idx].endOffset) return getActualToken(nodeTokens[idx], off); else if ((++idx < nodeTokens.length) && (off <= nodeTokens[idx].endOffset)) return getActualToken(nodeTokens[idx], off);
            }
        }
        idx = findTokenIndex(off);
        if ((0 <= idx) && (idx < nodeTokens.length)) return getActualToken(nodeTokens[idx], off);
        return null;
    }

    private int idx = 0;

    private static NodeToken getActualToken(NodeToken node, int off) {
        for (int i = 0; i < node.numSpecials(); i++) if (node.getSpecialAt(i).endOffset >= off) return node.getSpecialAt(i);
        if (node.endOffset >= off) return node;
        return null;
    }

    private int findTokenIndex(int off) {
        int a = 0;
        int b = nodeTokens.length;
        int idx = 0;
        while (a < b) {
            idx = (a + b) / 2;
            int bo = (idx > 0) ? nodeTokens[idx - 1].endOffset : 0;
            int eo = nodeTokens[idx].endOffset;
            if (off < bo) b = idx; else if (off > eo) a = idx + 1; else break;
        }
        return idx;
    }

    public String offsetToNodeToken(int off) {
        NodeToken nt = getToken(off);
        return "{image=\"" + nt + "\", kind=" + oscript.parser.OscriptParser.getTokenString(nt.kind) + "}";
    }
}
