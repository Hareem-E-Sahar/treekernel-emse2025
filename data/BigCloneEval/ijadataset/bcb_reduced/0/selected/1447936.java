package net.sourceforge.magex.preparation;

import java.io.DataOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 *  MapInformation stores all the map's meta information.
 */
public class MapInformation {

    /** File name constant -- map metainformation file name */
    private static final String MAP_META = "meta";

    /** Name of the corresponding section in polish map files */
    private static final String SECTION_NAME = "IMG ID";

    /** Map data -- "Level" */
    private static final String MAP_LEVEL = "Level";

    /** Map data -- "Levels" */
    private static final String MAP_LEVELS = "Levels";

    /** Map data -- "Name" */
    private static final String MAP_NAME = "Name";

    /** Map data -- "Zoom" */
    private static final String MAP_ZOOM = "Zoom";

    /** Map data -- "CodePage" */
    protected static final String MAP_CODEPAGE = "CodePage";

    /** Default code page (should never be used) */
    protected static final String DEFAULT_CODEPAGE = "1250";

    /** Map zoom levels -- base number */
    private static final int RECT_SIZES_BASE = 12;

    /** Map zoom levels -- corresponding rectangle sizes (X) */
    private static final int[] RECT_SIZES_X = { 4500000, 1800000, 720000, 450000, 180000, 108000, 45000, 27000, 18000, 7200, 4500, 1800, 1100 };

    /** Map zoom levels -- corresponding rectangle sizes (Y) */
    private static final int[] RECT_SIZES_Y = { 4500000, 1800000, 720000, 450000, 180000, 108000, 45000, 27000, 18000, 7200, 4500, 1800, 1100 };

    /** MP file default header -- start */
    public static final String DEFAULT_MP_HEADER_START = ";Generated by MaGeX Preparation\n\n[IMG ID]\n";

    /** MP file default header -- end */
    public static final String DEFAULT_MP_HEADER_END = "TreSize=4523\nRgnLimit=1024\n[END-IMG ID]\n\n";

    /** Map full name */
    public String name;

    /** X-coordinate of the top-left map corner */
    public int boundWest;

    /** Y-coordinate of the top-left map corner */
    public int boundSouth;

    /** X-coordinate of the bottom-right map corner */
    public int boundEast;

    /** Y-coordinate of the bottom-right map corner */
    public int boundNorth;

    /** Number of zoom levels */
    public byte zoomLevels;

    /** Rectangle horizontal sizes for each zoom level */
    public int[] rectangleSizesX;

    /** Rectangle vertical sizes for each zoom level */
    public int[] rectangleSizesY;

    /** If true, map is in RMS, if false map is in JAR */
    public boolean isInRMS;

    /** The total data size of the whole map */
    int fileSize;

    /** Bitmap of present indexes */
    int indexesPresent;

    /** The codepage of the input file (for possibility of writing .mp output later) */
    String inputCodePage;

    /** Constructor -- empty */
    public MapInformation() {
    }

    /** Constructor -- read the contents from the input file section */
    public MapInformation(InputFileSection in) throws DataPrepException {
        try {
            assert SECTION_NAME.equals(in.getName());
            this.name = in.get(MAP_NAME);
            assert this.name != null;
            this.zoomLevels = (byte) (Byte.parseByte(in.get(MAP_LEVELS)) - 1);
            assert this.zoomLevels >= 1;
            this.rectangleSizesX = new int[this.zoomLevels];
            this.rectangleSizesY = new int[this.zoomLevels];
            for (int i = 0; i < this.zoomLevels; ++i) {
                this.rectangleSizesX[i] = RECT_SIZES_X[Integer.parseInt(in.get(MAP_LEVEL + i)) - RECT_SIZES_BASE];
                this.rectangleSizesY[i] = RECT_SIZES_Y[Integer.parseInt(in.get(MAP_LEVEL + i)) - RECT_SIZES_BASE];
            }
            this.inputCodePage = in.get(MAP_CODEPAGE);
            if (this.inputCodePage == null) {
                this.inputCodePage = DEFAULT_CODEPAGE;
            }
        } catch (Exception e) {
            if (Main.DEBUG) e.printStackTrace();
            throw new DataPrepException(DataPrepException.INVALID_DATA);
        }
    }

    /** 
     * Rounds the value to Rectangle sizes for the given zoom level.
     *
     * @param y if true, works with y-coordinates, otherwise works with x-coordinates
     * @param zoomLevel the desired zoom level
     * @param val the value to be rounded
     * @return the rounded value
     */
    public int roundToRectangles(int val, int zoomLevel, boolean y) {
        if (y) {
            return (val / this.rectangleSizesY[zoomLevel]) * this.rectangleSizesY[zoomLevel];
        } else {
            return (val / this.rectangleSizesX[zoomLevel]) * this.rectangleSizesX[zoomLevel];
        }
    }

    /**
     * Creates a ZipEntry with the correct name and writes all the data into this 
     * ZIP output stream.
     *
     * @param mapId the id of the map for the entry name to be prefixed 
     * @param out the output stream to write into
     * @param dataSize the total size of the map's data records (-1 for embedding in JAR)
     */
    public void writeAllData(int mapId, ZipOutputStream out, int dataSize) throws IOException {
        DataOutputStream ds;
        out.putNextEntry(new ZipEntry(Process.MAP_DIR_PREFIX + mapId + Process.MAP_DIR_SEP + MAP_META));
        ds = new DataOutputStream(out);
        ds.writeInt(mapId);
        ds.writeUTF(this.name);
        ds.writeInt(this.boundWest);
        ds.writeInt(this.boundSouth);
        ds.writeInt(this.boundEast);
        ds.writeInt(this.boundNorth);
        ds.writeByte(this.zoomLevels);
        for (int i = 0; i < this.zoomLevels; ++i) {
            ds.writeInt(this.rectangleSizesX[i]);
            ds.writeInt(this.rectangleSizesY[i]);
        }
        if (dataSize == -1) {
            ds.writeInt(-1);
        } else {
            dataSize += ds.size() + 8;
            ds.writeInt(dataSize);
        }
        ds.writeInt(this.indexesPresent);
        ds.flush();
        out.closeEntry();
    }

    /**
     * Writes the header for the output .mp file.
     *
     * @param os the output stream to write to
     * @param charset the charset to be used
     */
    public void writePolishHeader(OutputStream os, Charset charset) throws IOException {
        os.write(DEFAULT_MP_HEADER_START.getBytes(charset));
        os.write((MAP_CODEPAGE + "=cp" + this.inputCodePage + "\n").getBytes(charset));
        os.write((MAP_NAME + "=" + this.name + "\n").getBytes(charset));
        os.write((MAP_LEVELS + "=" + (this.zoomLevels + 1) + "\n").getBytes(charset));
        for (int i = 0; i <= this.zoomLevels; ++i) {
            int levelNum = RECT_SIZES_BASE;
            if (i == this.zoomLevels) {
                levelNum = RECT_SIZES_BASE + RECT_SIZES_X.length - 1;
            } else {
                for (int j = 0; j < RECT_SIZES_X.length; ++j) {
                    if (this.rectangleSizesX[i] == RECT_SIZES_X[j]) {
                        levelNum += j;
                    }
                }
            }
            os.write((MAP_LEVEL + i + "=" + levelNum + "\n").getBytes(charset));
        }
        for (int i = 0; i <= this.zoomLevels; ++i) {
            os.write((MAP_ZOOM + i + "=" + i + "\n").getBytes(charset));
        }
        os.write(DEFAULT_MP_HEADER_END.getBytes(charset));
        os.flush();
    }

    /**
     * Limits the number of zoom levels for this map and returns the recount table. 
     * Removes all unneeded zoom levels (if ordered by conversion restrictions or 
     * empty), beginning with 0 (and makes the rectangleSizesX and rectangleSizesY shorter 
     * adequately).
     * 
     * @param restrictLevels the number of levels given in the map conversion restrictions
     * @param nonEmptyMask bit-mask for zoom level emptiness (1 = non-empty level, as numbered in the original map)
     * @return the zoom levels recount table (from old to new)
     */
    byte[] limitZoomLevels(byte restrictLevels, int nonEmptyMask) {
        int[] rectSizesXTmp, rectSizesYTmp;
        byte[] zoomLevelsRecount;
        byte totalNewLevels;
        byte j;
        if (restrictLevels >= this.zoomLevels && (nonEmptyMask == (((1 << this.zoomLevels) - 1) & (~(1 << restrictLevels) - 1)))) {
            return null;
        }
        totalNewLevels = restrictLevels;
        for (int i = this.zoomLevels - restrictLevels; i < this.zoomLevels; ++i) {
            if ((nonEmptyMask & (1 << i)) == 0) {
                --totalNewLevels;
            }
        }
        rectSizesXTmp = this.rectangleSizesX;
        rectSizesYTmp = this.rectangleSizesY;
        this.rectangleSizesX = new int[totalNewLevels];
        this.rectangleSizesY = new int[totalNewLevels];
        zoomLevelsRecount = new byte[this.zoomLevels];
        for (int i = 0; i < this.zoomLevels; ++i) {
            zoomLevelsRecount[i] = -1;
        }
        j = 0;
        for (int i = this.zoomLevels - restrictLevels; i < this.zoomLevels; ++i) {
            if ((nonEmptyMask & (1 << i)) != 0) {
                this.rectangleSizesX[j] = rectSizesXTmp[i];
                this.rectangleSizesY[j] = rectSizesYTmp[i];
                zoomLevelsRecount[i] = j;
                ++j;
            }
        }
        this.zoomLevels = totalNewLevels;
        return zoomLevelsRecount;
    }
}
