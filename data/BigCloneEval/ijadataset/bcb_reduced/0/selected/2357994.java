package oscript.swing.text;

import oscript.data.*;
import oscript.util.SymbolMap;
import oscript.syntaxtree.NodeToken;
import java.util.*;
import java.awt.Graphics;
import java.awt.Color;
import java.awt.Font;
import javax.swing.text.*;
import javax.swing.event.*;
import javax.swing.undo.CompoundEdit;

/**
 * An editor-kit for an ODE src code editor.  The document used is just
 * a plain-old {@link PlainDocument}.  Rather than trying to integrate the 
 * parser with the {@link Document}'s {@link Element} structure, the parsed
 * representation of the document is stored seperately as an array of tokens.
 * We create a {@link View} for rendering the document that takes into account
 * the token that overlays a section of text, and the {@link AttributeSet}
 * which that token maps to, as it renders the text.
 * <p>
 * For performance reasons, parsing happens asynchronously, which means that
 * whenever the document is mutated.  So, when there is an insert, we update
 * the (now out of date) tokens by increasing the end-offset of the current
 * token, and the begin-offset and end-offset of all subsequent tokens by the
 * number of characters inserted.  When there is a remove, the process is 
 * essentially the reverse.
 * <p>
 * The script side of things handles creating the parsing thread, and it uses
 * {@link DocumentListener}s to determine when reparsing is needed.
 * 
 * @author Rob Clark (rob@ti.com)
 * <!--$Format: " * @version $Revision$"$-->
 * @version 1.10
 * @see #createDefaultDocument
 */
public class ODEEditorKit extends DefaultEditorKit {

    private SymbolMap attrSetTable;

    private NodeToken[] nodeTokens = new NodeToken[0];

    /**
   * Class Constructor.
   */
    public ODEEditorKit() {
        attrSetTable = new SymbolMap();
    }

    /**
   * Set the attribute set table.
   * 
   * @param attrSetTable the table that maps NodeToken.kind to an attribute
   *    set.  This table is created and maintained from script code, but
   *    used here while rendering the text.
   */
    public void setAttributeSetTable(SymbolMap attrSetTable) {
        this.attrSetTable = attrSetTable;
    }

    /**
   * Called from script code after parsing is completed.  For performance
   * reasons the tokens are stored here, after they are generated by script.
   */
    public synchronized void setNodeTokens(Vector v) {
        NodeToken[] newNodeTokens = new NodeToken[v.size()];
        v.copyInto(newNodeTokens);
        nodeTokens = newNodeTokens;
    }

    /**
   * Get a factory for producing {@link View}s for rendering {@link Document}s
   * created by this editor-kit.
   * 
   * @return the view-factory
   */
    public ViewFactory getViewFactory() {
        return new ViewFactory() {

            public View create(Element elem) {
                return new NodeTokenView(elem);
            }
        };
    }

    /**
   * Create a uninitialized document.  The {@link Document} used by this editor
   * kit is basically just a {@link PlainDocument} that has been extended to
   * synchronously update the offsets of the tokens in response to document
   * mutations (insert/remove).  This is important to ensure that the token's
   * offset maps to sensible positions in the document during the period between
   * when the document is edited, and when the parser has finished re-parsing it
   * 
   * @return an unitialized document
   */
    public Document createDefaultDocument() {
        return new ODEDocument();
    }

    public class ODEDocument extends PlainDocument {

        private long lastMutateTime;

        public long getLastMutateTime() {
            return lastMutateTime;
        }

        private int undoableSequenceLevel = 0;

        private CompoundEdit undoableSequence = null;

        /**
     * All document updates performed by the runnable result in a single
     * undo event.  This call gate provides a way to coalesce multiple
     * insert/remove mutates into a single undoable event.
     */
        public void performUndoableSequence(Runnable r) {
            synchronized (ODEEditorKit.this) {
                undoableSequenceLevel++;
                r.run();
                undoableSequenceLevel--;
                if ((undoableSequenceLevel == 0) && (undoableSequence != null)) {
                    undoableSequence.end();
                    super.fireUndoableEditUpdate(new UndoableEditEvent(this, undoableSequence));
                    undoableSequence = null;
                }
            }
        }

        private CompoundEdit getUndoableSequence() {
            if (undoableSequence == null) {
                undoableSequence = new CompoundEdit();
            }
            return undoableSequence;
        }

        protected void fireUndoableEditUpdate(UndoableEditEvent evt) {
            synchronized (ODEEditorKit.this) {
                if (undoableSequenceLevel > 0) getUndoableSequence().addEdit(evt.getEdit()); else super.fireUndoableEditUpdate(evt);
            }
        }

        /**
     * Get a reader that returns the contents of this document
     */
        public java.io.Reader getDocumentReader() {
            return new java.io.Reader() {

                private int idx = 0;

                public int read(char[] cbuf, int off, int len) throws java.io.IOException {
                    try {
                        len = Math.min(len, getLength() - idx);
                        len = Math.min(len, 128);
                        System.arraycopy(getText(idx, len).toCharArray(), 0, cbuf, off, len);
                        idx += len;
                        if (len == 0) return -1;
                        return len;
                    } catch (BadLocationException e) {
                        throw new java.io.IOException("bad location: " + e.getMessage());
                    }
                }

                public void close() {
                }
            };
        }

        public void remove(int off, int len) throws BadLocationException {
            synchronized (ODEEditorKit.this) {
                lastMutateTime = System.currentTimeMillis();
                off = Math.max(off, 0);
                len = Math.min(off + len, getLength()) - off;
                updateRemove(off, len);
                super.remove(off, len);
            }
        }

        public void insertString(int off, String str, AttributeSet a) throws BadLocationException {
            synchronized (ODEEditorKit.this) {
                lastMutateTime = System.currentTimeMillis();
                updateInsert(off, str.length());
                super.insertString(off, str, a);
            }
        }
    }

    private synchronized void updateInsert(int off, int len) {
        NodeToken nt = getToken(off);
        if (nt != null) {
            LinkedList tokenList = new LinkedList();
            tokenList.add(nt);
            while ((nt = getToken(nt.endOffset + 1)) != null) tokenList.add(nt);
            Iterator itr = tokenList.iterator();
            ((NodeToken) (itr.next())).endOffset += len;
            while (itr.hasNext()) {
                nt = (NodeToken) (itr.next());
                nt.beginOffset += len;
                nt.endOffset += len;
            }
        }
    }

    private final synchronized void updateRemove(int off, int len) {
        NodeToken nt = getToken(off - len);
        if (nt != null) {
            int totalSub = 0;
            LinkedList tokenList = new LinkedList();
            tokenList.add(nt);
            while ((nt = getToken(nt.endOffset + 1)) != null) tokenList.add(nt);
            for (Iterator itr = tokenList.iterator(); itr.hasNext(); ) {
                nt = (NodeToken) (itr.next());
                int sub = len - Math.max(0, off + len - nt.endOffset);
                len -= sub;
                off += sub;
                nt.beginOffset -= totalSub;
                totalSub += sub;
                nt.endOffset -= totalSub;
            }
        }
    }

    /**
   * The {@link View} implementation.  Basically just a {@link PlainView} that 
   * changes the attribute-set for different node tokens within the view as it 
   * renders.
   */
    private class NodeTokenView extends PlainView {

        private Segment text = new Segment();

        /**
     * Class Constructor.
     */
        NodeTokenView(Element elem) {
            super(elem);
        }

        /**
     * Renders the given range in the model as normal unselected
     * text.  Uses the foreground or disabled color to render the text.
     *
     * @param g the graphics context
     * @param x the starting X coordinate >= 0
     * @param y the starting Y coordinate >= 0
     * @param p0 the beginning position in the model >= 0
     * @param p1 the ending position in the model >= 0
     * @returns the X location of the end of the range >= 0
     * @exception BadLocationException if the range is invalid
     */
        protected synchronized int drawUnselectedText(Graphics g, int x, int y, int p0, int p1) throws BadLocationException {
            if ((nodeTokens == null) || (nodeTokens.length == 0)) return super.drawUnselectedText(g, x, y, p0, p1);
            Document doc = getDocument();
            int p = p0;
            int kind = -1;
            while (p < p1) {
                NodeToken nt = getToken(p);
                int mark;
                if (nt == null) {
                    setKind(g, -1);
                    mark = p1;
                } else {
                    if (kind != nt.kind) setKind(g, kind = nt.kind);
                    mark = Math.min(nt.endOffset + 1, p1);
                }
                if (mark > p) {
                    doc.getText(p, mark - p, text);
                    x = Utilities.drawTabbedText(text, x, y, g, this, mark);
                }
                p = mark;
            }
            return x;
        }

        private void setKind(Graphics g, int kind) {
            if (kind >= oscript.util.SymbolTable.MIN_SYMBOL_ID) {
                AttributeSet attrSet = (AttributeSet) (attrSetTable.get(kind));
                g.setColor(getFgColor(attrSet));
                g.setFont(getFont(g.getFont(), attrSet));
            } else {
                g.setColor(Color.black);
            }
        }
    }

    private static Color defaultFgColor = Color.black;

    public static void setDefaultFgColor(Color c) {
        defaultFgColor = c;
    }

    /**
   * Given an attribute set, get the foreground color
   */
    private static Color getFgColor(AttributeSet attrSet) {
        Color c = null;
        if (attrSet != null) c = (Color) (attrSet.getAttribute(StyleConstants.Foreground));
        if (c == null) c = defaultFgColor;
        return c;
    }

    /**
   * All editor-kits share a common font cache, keyed by an instance of
   * {@link FontCacheKey}.
   */
    private static Hashtable fontCache = new Hashtable();

    private static class FontCacheKey {

        private String name;

        private int style;

        private int size;

        private int hash;

        FontCacheKey(String name, int style, int size) {
            this.name = name;
            this.style = style;
            this.size = size;
            hash = name.hashCode() ^ ((style << 16) | size);
        }

        public int hashCode() {
            return hash;
        }

        public boolean equals(Object obj) {
            return (obj instanceof FontCacheKey) && (((FontCacheKey) obj).hash == hash) && ((FontCacheKey) obj).name.equals(name) && (((FontCacheKey) obj).style == style) && (((FontCacheKey) obj).size == size);
        }
    }

    /**
   * Given an attribute set, get the font.  For performance reasons,
   * this avoids re-instantiating fonts, and caches fonts keys by 
   * &lt; name, style size &gt;.  (Use of Font#deriveFont() would be
   * easier, but is buggy on early versions of java v1.4 on macosx)
   */
    private static Font getFont(Font origFont, AttributeSet attrSet) {
        int style = Font.PLAIN;
        if (attrSet != null) {
            Integer val = (Integer) (attrSet.getAttribute("style"));
            if (val != null) style = val.intValue();
        }
        Object key = new FontCacheKey(origFont.getName(), style, origFont.getSize());
        Font font = (Font) (fontCache.get(key));
        if (font == null) {
            font = new Font(origFont.getName(), style, origFont.getSize());
            fontCache.put(key, font);
        }
        return font;
    }

    /**
   * Given an offset into the document, find the corresponding token.
   * This is the API used by everything else for accessing the tokens.
   * The remaining methods are just used to implement this method.
   * 
   * @param off          the offset into the document
   */
    public synchronized NodeToken getToken(int off) {
        if ((0 <= idx) && (idx < nodeTokens.length)) {
            if (off >= nodeTokens[idx].getActualBeginOffset()) {
                if (off <= nodeTokens[idx].endOffset) return getActualToken(nodeTokens[idx], off); else if ((++idx < nodeTokens.length) && (off <= nodeTokens[idx].endOffset)) return getActualToken(nodeTokens[idx], off);
            }
        }
        idx = findTokenIndex(off);
        if ((0 <= idx) && (idx < nodeTokens.length)) return getActualToken(nodeTokens[idx], off);
        return null;
    }

    private int idx = 0;

    private static NodeToken getActualToken(NodeToken node, int off) {
        for (int i = 0; i < node.numSpecials(); i++) if (node.getSpecialAt(i).endOffset >= off) return node.getSpecialAt(i);
        if (node.endOffset >= off) return node;
        return null;
    }

    private int findTokenIndex(int off) {
        int a = 0;
        int b = nodeTokens.length;
        int idx = 0;
        while (a < b) {
            idx = (a + b) / 2;
            int bo = (idx > 0) ? nodeTokens[idx - 1].endOffset : 0;
            int eo = nodeTokens[idx].endOffset;
            if (off < bo) b = idx; else if (off > eo) a = idx + 1; else break;
        }
        return idx;
    }

    public String offsetToNodeToken(int off) {
        NodeToken nt = getToken(off);
        return "{image=\"" + nt + "\", kind=" + oscript.parser.OscriptParser.getTokenString(nt.kind) + "}";
    }
}
